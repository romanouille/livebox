#!/bin/sh /etc/rc.common
# Copyright (C) 2011 Sagemcom
START=25

. /etc/sysdirs.conf
. /etc/gui-core.conf
if [ -f /etc/gui-xmo.conf ]; then
  . /etc/gui-xmo.conf
fi
if [ -f /etc/gui.conf ]; then
  . /etc/gui.conf
fi
if [ -f /etc/gui-remote-ssh.conf ]; then
	. /etc/gui-remote-ssh.conf
fi
. /etc/flash-map.conf
. /etc/device-info.conf

UBIDEV=/dev/ubi0
LIGHTTPD_VERSION=/etc/lighttpd/conf.d/gui-version.conf

# La version du Web API fournit pas par FT 
WEB_API_VERSION=2

ROOT_FILESYSTEM_FORMAT=`cat /proc/cmdline | grep squashfs`

if [ x"$ROOT_FILESYSTEM_FORMAT" != x"" ]; then
GUI_CORE=`echo "$GUI_CORE" | sed -e 's/\(\/usr\/share\/\)/\/opt\/squashfs\1/g'`
GUI_XMO=`echo "$GUI_XMO" | sed -e 's/\(\/usr\/share\/\)/\/opt\/squashfs\1/g'`
GUI_DEFAULT_OPT=`echo "$GUI_DEFAULT_OPT" | sed -e 's/\(\/usr\/share\/\)/\/opt\/squashfs\1/g'`
DEVICE_INFO=`echo "$DEVICE_INFO" | sed -e 's/\(\/usr\/share\/\)/\/opt\/squashfs\1/g'`
GUI_REMOTE_SSH=`echo "$GUI_REMOTE_SSH" | sed -e 's/\(\/usr\/share\/\)/\/opt\/squashfs\1/g'`
fi

init_ubi () {
  if [ x"$CONFIG_MTD_SECURE_UPDATE_UBI" != x"" ]; then
    for vol in /sys/class/ubi/ubi0/ubi0_*
    do
      if [ `cat $vol/name` = "$1" ]; then
        basename $vol
        return 0
      fi
    done
    # Try to create the volume
    VOL_SIZE=`expr $CONFIG_MTD_SECURE_UPDATE_GUI_SIZE "*" $CONFIG_MTD_SECURE_UPDATE_LEB_SIZE`
    if (ubimkvol "$UBIDEV" -N "$1" -s "$VOL_SIZE" -t static > /dev/null); then
      for vol in /sys/class/ubi/ubi0/ubi0_*
      do
        if [ `cat $vol/name` = "$1" ]; then
          basename $vol
          return 0
        fi
      done
      return 1
    fi
    echo "Cannot create UBI volume for $1 !" >&2
    return 1
  fi
}

find_mtd () {
  (cat /proc/mtd | \
    grep "\"$1\"" | \
    cut -d ":" -f 1 | \
    sed -e 's/^mtd\([0-9]*\)$/\/dev\/mtdblock\1/' ) 2> /dev/null \
    || echo "" ;
}

check_image () {
  if [ -x /usr/sbin/gsdf-verif ]; then
    /usr/sbin/gsdf-verif "$1" 2> /dev/null 1> /dev/null
    if [ $? -eq 0 ]; then
      echo "Valid GUI image"
      # Check the GUI firmware version
      GUI_FIRMWARE_VERSION=`head -c 42 $UBI_DEVICE | tail -c 10 2> /dev/null`
      GUI_VERSION=`echo -n "$GUI_FIRMWARE_VERSION" | cut -c 5-6 | sed -e 's/^0*//'`
      if [ "$GUI_VERSION" -lt "$WEB_API_VERSION" ]; then
        echo "Invalid GUI version: $GUI_VERSION (GUI version=$GUI_FIRMWARE_VERSION, Web API version=$WEB_API_VERSION) !"
        return 1
      fi
      # Generate the lighttpd version config
      GUI_MINOR=`echo -n "$GUI_FIRMWARE_VERSION" | cut -c 7-8 | sed -e 's/^0*//'`
      GUI_REVISION=`echo -n "$GUI_FIRMWARE_VERSION" | cut -c 9-10 | sed -e 's/^0*//'`
      echo "# Generated by gui-firmware" > $LIGHTTPD_VERSION
      echo "var.version = \"$GUI_VERSION.$GUI_MINOR.$GUI_REVISION\"" >> $LIGHTTPD_VERSION
      echo "var.version_expr = \"$GUI_VERSION\\.$GUI_MINOR\\.$GUI_REVISION\"" >> $LIGHTTPD_VERSION
      return 0
    else
      echo "Invalid RSA or empty external GUI image"
      RESULT=1
    fi
  else
    echo "'gsdf-verif' unavailable, try 'checkfirmware'"
    RESULT=0
  fi
  if [ -x /usr/bin/checkfirmware ]; then
    /usr/bin/checkfirmware "$1" 2> /dev/null 1> /dev/null
    if [ $? -eq 0 ]; then
      echo "Valid firmware image"
      return 0
    else
      echo "Invalid DSA or empty external GUI image"
      return 1
    fi
  else
    if [ $RESULT -ne 0 ]; then
      echo "'checkfirmware' unavailable, not checking image"
    fi
  fi
  return $RESULT
}

mount_squashfs () {
  mount -t squashfs $1 $2 2> /dev/null
}

mount_gui () {
  UBI_DEVICE=/dev/`init_ubi "$1" "$2"`
  # Check the GUI firmware device
  if !(check_image "$UBI_DEVICE"); then
    return 1
  fi
  # Mount squashfs on the block device
  GUI_DEVICE=`find_mtd "$3"`
  if [ x"$GUI_DEVICE" != x"" ]; then
    if !(mount_squashfs $GUI_DEVICE $4); then
      echo "Cannot mount SQUASHFS ($GUI_DEVICE) on $4 !"
      return 1
    fi
    return 0
  else
    echo "No $1 MTD device !"
    return 1
  fi
}

start() {
  # GUI core libraries from rootfs
  UNION_OPT="$GUI_CORE"
  if [ x"$GUI_XMO" != x"" ]; then
    echo "Install the GUI XMO from rootfs"
    UNION_OPT="$GUI_XMO":"$UNION_OPT"
  fi
  # GUI Remote SSH 
  if [ x"$GUI_REMOTE_SSH" != x"" ]; then
    echo "Install the GUI XMO from rootfs"
    UNION_OPT="$GUI_REMOTE_SSH":"$UNION_OPT"
  fi
  # Add GUI from /opt/data
  for gui in /opt/data/gui-*/www
  do
    if [ -d $gui ]; then
      # Add GUI check here !!!
      UNION_OPT="$gui":"$UNION_OPT"
    fi
  done
  # Try to mount the externalized GUI filesystem
  VOL_SIZE=`expr $CONFIG_MTD_SECURE_UPDATE_GUI_SIZE "*" $CONFIG_MTD_SECURE_UPDATE_LEB_SIZE`
  if [ x"$CONFIG_MTD_SECURE_UPDATE_GUI_PARTITION" != x"" ] && \
     (mount_gui "gui" "$VOL_SIZE" "guifs" "$GUI_DIR"); then
    echo "Install externalized GUI (mount $GUI_DIR)"
    UNION_OPT="$GUI_DIR":"$UNION_OPT"
  elif [ -f /etc/gui.conf ]; then
    echo "Install the default rootfs GUI"
    UNION_OPT="$GUI_DEFAULT_OPT":"$UNION_OPT"
  fi
  # Include supported data models
  UNION_OPT="$DEVICE_INFO:$UNION_OPT"
  if [ -d /etc/gui/conf.d ]; then
    for guiconf in /etc/gui/conf.d/*
    do
      if [ -f "$guiconf" ]; then
        . "$guiconf"
      fi
    done
  fi
  mount -t unionfs -o ro,dirs="$UNION_OPT" none "$WWW_DIR"

}

stop() {
  echo "Umount GUI file systems"
  umount "$WWW_DIR" 2> /dev/null || echo "Cannot umount $WWW_DIR !" >&2
  if [ x"$CONFIG_MTD_SECURE_UPDATE_GUI_PARTITION" != x"" ]; then
    umount "$GUI_DIR" 2> /dev/null || echo "Cannot umount $GUI_DIR !" >&2
  fi
}

restart() {
  stop
  start
}

